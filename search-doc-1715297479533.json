[{"title":"About","type":0,"sectionRef":"#","url":"/SimplyReplicate/docs/intro","content":"","keywords":""},{"title":"Features​","type":1,"pageTitle":"About","url":"/SimplyReplicate/docs/intro#features","content":"Strictly Typed: SimplyReplicate is strictly typed in Luau, meaning everything is correctly typed and you won't have to worry about runtime errors because you put a value in the wrong place.Player Specific Replication: If you ever need to replicate different data to different players, you can 100% do that with SimplyReplicate with the same replicator. SimplyReplicate will handle all the replication for you.Always in Sync: SimplyReplicate will ensure that all clients are properly receiving the exact data that the server has, and you worry about out of sync data.Accessing Data: On both the server and the client, you can access the data in the replicator at any time, and it will always be up to date. You can even get the data for a specific player on the server if you need to.Signal Based: SimplyReplicate uses signals to notify you when the data has changed, so you can easily listen for changes and handle them accordingly.Efficient: SimplyReplicate is built to be efficient with network usage, meaning if you only modify one state, only that state will be replicated to the clients.Easy to Use: SimplyReplicate is designed to be easy to use, with a simple API and easy to understand documentation. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/SimplyReplicate/docs/gettingstarted","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"Getting Started","url":"/SimplyReplicate/docs/gettingstarted#install","content":"Installing SimplyReplicate is very simple. You can either download the module from the Releases Page or install it using Wally. Roblox Studio: Get the rbxm file from the Releases Page and insert it into your game Wally: Add SimplyReplicate to your wally.toml dependency list (e.g. SimplyReplicate = &quot;colrealpro/simplyreplicate@^0.1.4&quot;)Run wally install in your terminal Wally Not familiar with Wally? Wally is a package manager (like NPM) for the Roblox ecosystem. To get started, check out the Wally repository. "},{"title":"Basic Usage​","type":1,"pageTitle":"Getting Started","url":"/SimplyReplicate/docs/gettingstarted#basic-usage","content":"For this example I will demonstrate creating a very simple status replication system On both the client and the server you are going to want to create a replicator with the same key, and specify the default states and their default values Server: local Replicator = require(path.to.module) local GameStateReplicator = Replicator.new(&quot;GameState&quot;, { Status = &quot;Waiting for players&quot;, RoundStarted = false })  info Whatever states you specify when creating the replicator will be the only states you can change, otherwise an error will be thrown note If you are using strict Luau, you will want to add a type cast to the second argument to make everything optional, this way when you go to use the changeStates method, you won't have to worry about TypeErrors for missing states Client: local Replicator = require(path.to.module) local GameStateReplicator = Replicator.new(&quot;GameState&quot;)  Great! We now have a replicator on both the client and the server, now we can start changing the states and they will be replicated to the client! To change a state in the replicator we will use the changeStates method as seen below Server: GameStateReplicator:changeStates({ Status = &quot;Game starting in 5 seconds&quot; })  note You do not need to specify all the states when changing them, only the ones you want to change Now that we have the server able to change the states, we need to listen for the changes on the client, to do this we will use the StateChanged signal as seen below Client: GameStateReplicator.StateChanged:Connect(function(state, value) print(state, value) -- Status, Game starting in 5 seconds end)  Hooraay! You have now successfully created a simple status replication system using SimplyReplicate! This is just the tip of the iceberg, there are many more features and use cases for SimplyReplicate, so be sure to check out Replicating Data or the API Reference for more information. "},{"title":"Maid","type":0,"sectionRef":"#","url":"/SimplyReplicate/api/Maid","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Maid","url":"/SimplyReplicate/api/Maid#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Maid","url":"/SimplyReplicate/api/Maid#new","content":"&lt;/&gt; Maid.new() → Maid Constructs a new Maid object local maid = Maid.new()   "},{"title":"isMaid​","type":1,"pageTitle":"Maid","url":"/SimplyReplicate/api/Maid#isMaid","content":"&lt;/&gt; Maid.isMaid(value: any) → boolean Returns true if the class is a maid, and false otherwise. print(Maid.isMaid(Maid.new())) --&gt; true print(Maid.isMaid(nil)) --&gt; false   "},{"title":"Destroy​","type":1,"pageTitle":"Maid","url":"/SimplyReplicate/api/Maid#Destroy","content":"&lt;/&gt; Maid.Destroy() → () Alias for Maid.DoCleaning()  "},{"title":"__index​","type":1,"pageTitle":"Maid","url":"/SimplyReplicate/api/Maid#__index","content":"&lt;/&gt; Maid:__index(index: any) → MaidTask Returns Maid[key] if not part of Maid metatable local maid = Maid.new() maid._current = Instance.new(&quot;Part&quot;) print(maid._current) --&gt; Part maid._current = nil print(maid._current) --&gt; nil   "},{"title":"__newindex​","type":1,"pageTitle":"Maid","url":"/SimplyReplicate/api/Maid#__newindex","content":"&lt;/&gt; Maid:__newindex( index: any, newTask: MaidTask ) → () Add a task to clean up. Tasks given to a maid will be cleaned when maid[index] is set to a different value. Task cleanup is such that if the task is an event, it is disconnected. If it is an object, it is destroyed. Maid[key] = (function) Adds a task to perform Maid[key] = (event connection) Manages an event connection Maid[key] = (thread) Manages a thread Maid[key] = (Maid) Maids can act as an event connection, allowing a Maid to have other maids to clean up. Maid[key] = (Object) Maids can cleanup objects with a `Destroy` method Maid[key] = nil Removes a named task.   "},{"title":"Add​","type":1,"pageTitle":"Maid","url":"/SimplyReplicate/api/Maid#Add","content":"&lt;/&gt; Maid:Add( task: MaidTask-- An item to clean ) → MaidTask Gives a task to the maid for cleanup and returns the resulting value  "},{"title":"GiveTask​","type":1,"pageTitle":"Maid","url":"/SimplyReplicate/api/Maid#GiveTask","content":"&lt;/&gt; Maid:GiveTask( task: MaidTask-- An item to clean ) → number-- taskId Gives a task to the maid for cleanup, but uses an incremented number as a key.  "},{"title":"GivePromise​","type":1,"pageTitle":"Maid","url":"/SimplyReplicate/api/Maid#GivePromise","content":"&lt;/&gt; Maid:GivePromise(promise: Promise&lt;T&gt;) → Promise&lt;T&gt; Gives a promise to the maid for clean.  "},{"title":"DoCleaning​","type":1,"pageTitle":"Maid","url":"/SimplyReplicate/api/Maid#DoCleaning","content":"&lt;/&gt; Maid:DoCleaning() → () Cleans up all tasks and removes them as entries from the Maid. note Signals that are already connected are always disconnected first. After that any signals added during a cleaning phase will be disconnected at random times. tip DoCleaning() may be recursively invoked. This allows the you to ensure that tasks or other tasks. Each task will be executed once. However, adding tasks while cleaning is not generally a good idea, as if you add a function that adds itself, this will loop indefinitely. "},{"title":"Replicator","type":0,"sectionRef":"#","url":"/SimplyReplicate/api/Replicator","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Replicator","url":"/SimplyReplicate/api/Replicator#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Replicator","url":"/SimplyReplicate/api/Replicator#new","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Replicator.new( identifier: string | Instance , data: {[string]: any}-- The data that will be replicated to clients ) → Replicator Constructs a new replicator warning When creating a replicator on the client, this function will yield until the initial data has been fetched from the server info Note that if you are using strict luau, you will want to specify a type for the data parameter, if you let Luau infer the type, when you go to change the state, it will want you to include every state as it wont have an option to be nil.  "},{"title":"changeStates​","type":1,"pageTitle":"Replicator","url":"/SimplyReplicate/api/Replicator#changeStates","content":"&lt;/&gt; Replicator:changeStates( changedStates: {[string]: any?},-- The states that have been changed and their new values players: ({Player } | Player )? ) → () Changes states in the replicator and replicate whatever changes to the clients "},{"title":"Errors","type":1,"pageTitle":"Replicator","url":"/SimplyReplicate/api/Replicator##","content":"Type\tDescription&quot;Invalid state&quot;\tThrown when the state does not exist in the data structure  "},{"title":"syncPlayer​","type":1,"pageTitle":"Replicator","url":"/SimplyReplicate/api/Replicator#syncPlayer","content":"&lt;/&gt; Replicator:syncPlayer(player: Player ) → () Syncs a player's state with the server's state  "},{"title":"get​","type":1,"pageTitle":"Replicator","url":"/SimplyReplicate/api/Replicator#get","content":"&lt;/&gt; Replicator:get( index: string?-- If provided, returns the state given, otherwise returns all states ) → {[string]: any} | any Returns the current state stored in the replicator "},{"title":"Errors","type":1,"pageTitle":"Replicator","url":"/SimplyReplicate/api/Replicator##","content":"Type\tDescription&quot;Invalid state&quot;\tThrown when the state does not exist in the data structure  "},{"title":"getForPlayer​","type":1,"pageTitle":"Replicator","url":"/SimplyReplicate/api/Replicator#getForPlayer","content":"&lt;/&gt; Replicator:getForPlayer( player: Player , index: string?-- If provided, returns the state given, otherwise returns all states ) → {[string]: any} | any Returns the current state stored in the replicator for a specific player "},{"title":"Errors","type":1,"pageTitle":"Replicator","url":"/SimplyReplicate/api/Replicator##","content":"Type\tDescription&quot;Invalid state&quot;\tThrown when the state does not exist in the data structure  "},{"title":"Destroy​","type":1,"pageTitle":"Replicator","url":"/SimplyReplicate/api/Replicator#Destroy","content":"&lt;/&gt; Replicator:Destroy() → () This function should be called when you are done using the replicator "},{"title":"Replicating Data","type":0,"sectionRef":"#","url":"/SimplyReplicate/docs/replicatingdata","content":"","keywords":""},{"title":"Creating a Replicator​","type":1,"pageTitle":"Replicating Data","url":"/SimplyReplicate/docs/replicatingdata#creating-a-replicator","content":"To create a module, all you will need to do is pass the identifier of the replicator and the states and their default values that will be replicated to the client. Important Whatever states you specify when creating the replicator will be the only states you can change, otherwise an error will be thrown. tip When it comes to the identifier of the replicator, you aren't limited to a string! You can use a instance as well, such as a Model or a Folder! Server: local Replicator = require(path.to.module) local ExampleReplicator = Replicator.new(&quot;ExampleReplicator&quot;, { ExampleState = &quot;ExampleValue&quot;, ExampleNumber = 0, ExampleBoolean = false, ExampleTable = { Very = &quot;Cool&quot; } })  Client: local Replicator = require(path.to.module) local ExampleReplicator = Replicator.new(&quot;ExampleReplicator&quot;)  "},{"title":"Listening to Data Changes​","type":1,"pageTitle":"Replicating Data","url":"/SimplyReplicate/docs/replicatingdata#listening-to-data-changes","content":"To listen to data changes on the client, you can use the StateChanged signal on the replicator. This signal will fire whenever a state is changed, and will provide the state and new value as arguments. ExampleReplicator.StateChanged:Connect(function(state, value) print(state, value) end)  "},{"title":"Changing States​","type":1,"pageTitle":"Replicating Data","url":"/SimplyReplicate/docs/replicatingdata#changing-states","content":"To change a state in the replicator, you can use the changeStates method. This method will take a table of states and their new values, and will replicate them to the client. ExampleReplicator:changeStates({ ExampleState = &quot;NewValue&quot;, ExampleNumber = 5, ExampleBoolean = true, ExampleTable = { Very = &quot;Cooler&quot; } })  "},{"title":"Specific Player States​","type":1,"pageTitle":"Replicating Data","url":"/SimplyReplicate/docs/replicatingdata#specific-player-states","content":"If you ever need to replicate different data to different players, you can do that very easily using the same replicator. In order to do this, you will need to use the changeStates method the same way you would normally, but instead, you will specify the players you want to replicate the data to. -- Replicating to a specific player ExampleReplicator:changeStates({ ExampleState = &quot;NewValue&quot; }, player) -- Replicating to multiple players ExampleReplicator:changeStates({ ExampleState = &quot;NewValue&quot; }, { player1, player2, player3 })  To the clients, this will act the exact same as if you were to change the states normally, but only the specified players will receive the new data, and they will still receive state updates that are not player specific as well. On top of this, the server will store a copy of what each player has, so you can access the data for a specific player at any time (See Accessing Data for more information). tip At some point you may want to resync a player back with the server's data, see Syncing Players to learn how to do this. "},{"title":"Accessing Data​","type":1,"pageTitle":"Replicating Data","url":"/SimplyReplicate/docs/replicatingdata#accessing-data","content":"On both the server and the client, you can access the data in the replicator at any time, and it will always be up to date. You can even get the data for a specific player on the server if you need to. -- Accessing all the data local data = ExampleReplicator:get() print(data) -- prints all the data in the replicator -- Accessing a specific state local ExampleState = ExampleReplicator:get(&quot;ExampleState&quot;) print(ExampleState) -- prints the value of ExampleState -- Accessing a specific player's data local playerData = ExampleReplicator:getForPlayer(player) local playerExampleState = ExampleReplicator:getForPlayer(player, &quot;ExampleState&quot;) print(playerData) -- prints all the data for the player print(playerExampleState) -- prints the value of ExampleState for the player  Accessing Player Specific Data If you attempt to access player specific data on the client, it will throw an error. The client only has access to the data that is replicated to it, and it does not have access to the data for other players. "},{"title":"Syncing Players​","type":1,"pageTitle":"Replicating Data","url":"/SimplyReplicate/docs/replicatingdata#syncing-players","content":"If you have set player specific data for a player, you may want to at some point resync the player with the server's data. This can be done using the syncPlayer method. ExampleReplicator:syncPlayer(player)  Doing this will tell the client to revert all specific changes and replace them with the server's data. This will also fire the StateChanged signal for the client as usual. "},{"title":"Signal","type":0,"sectionRef":"#","url":"/SimplyReplicate/api/Signal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Signal","url":"/SimplyReplicate/api/Signal#types","content":" "},{"title":"SignalConnection​","type":1,"pageTitle":"Signal","url":"/SimplyReplicate/api/Signal#SignalConnection","content":"&lt;/&gt; interface SignalConnection { Connected: boolean Disconnect: (SignalConnection) → () } Represents a connection to a signal. local connection = signal:Connect(function() end) print(connection.Connected) --&gt; true connection:Disconnect() print(connection.Connected) --&gt; false   "},{"title":"ConnectionFn​","type":1,"pageTitle":"Signal","url":"/SimplyReplicate/api/Signal#ConnectionFn","content":"&lt;/&gt; type ConnectionFn = (...any) → () A function connected to a signal. "},{"title":"Functions​","type":1,"pageTitle":"Signal","url":"/SimplyReplicate/api/Signal#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Signal","url":"/SimplyReplicate/api/Signal#new","content":"&lt;/&gt; Signal.new() → Signal Constructs a new Signal  "},{"title":"Wrap​","type":1,"pageTitle":"Signal","url":"/SimplyReplicate/api/Signal#Wrap","content":"&lt;/&gt; Signal.Wrap( rbxScriptSignal: RBXScriptSignal -- Existing RBXScriptSignal to wrap ) → Signal Constructs a new Signal that wraps around an RBXScriptSignal. For example: local signal = Signal.Wrap(workspace.ChildAdded) signal:Connect(function(part) print(part.Name .. &quot; added&quot;) end) Instance.new(&quot;Part&quot;).Parent = workspace   "},{"title":"Is​","type":1,"pageTitle":"Signal","url":"/SimplyReplicate/api/Signal#Is","content":"&lt;/&gt; Signal.Is( obj: any-- Object to check ) → boolean-- true if the object is a Signal. Checks if the given object is a Signal.  "},{"title":"Connect​","type":1,"pageTitle":"Signal","url":"/SimplyReplicate/api/Signal#Connect","content":"&lt;/&gt; Signal:Connect(fn: ConnectionFn) → SignalConnection Connects a function to the signal, which will be called anytime the signal is fired. signal:Connect(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25)   "},{"title":"Once​","type":1,"pageTitle":"Signal","url":"/SimplyReplicate/api/Signal#Once","content":"&lt;/&gt; Signal:Once(fn: ConnectionFn) → SignalConnection Connects a function to the signal, which will be called the next time the signal fires. Once the connection is triggered, it will disconnect itself. signal:Once(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25) signal:Fire(&quot;This message will not go through&quot;, 10)   "},{"title":"DisconnectAll​","type":1,"pageTitle":"Signal","url":"/SimplyReplicate/api/Signal#DisconnectAll","content":"&lt;/&gt; Signal:DisconnectAll() → () Disconnects all connections from the signal. signal:DisconnectAll()   "},{"title":"Fire​","type":1,"pageTitle":"Signal","url":"/SimplyReplicate/api/Signal#Fire","content":"&lt;/&gt; Signal:Fire(...: any) → () Fire the signal, which will call all of the connected functions with the given arguments. signal:Fire(&quot;Hello&quot;) -- Any number of arguments can be fired: signal:Fire(&quot;Hello&quot;, 32, {Test = &quot;Test&quot;}, true)   "},{"title":"FireDeferred​","type":1,"pageTitle":"Signal","url":"/SimplyReplicate/api/Signal#FireDeferred","content":"&lt;/&gt; Signal:FireDeferred(...: any) → () Same as Fire, but uses task.defer internally &amp; doesn't take advantage of thread reuse. signal:FireDeferred(&quot;Hello&quot;)   "},{"title":"Wait​","type":1,"pageTitle":"Signal","url":"/SimplyReplicate/api/Signal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Signal:Wait() → ...any Yields the current thread until the signal is fired, and returns the arguments fired from the signal. Yielding the current thread is not always desirable. If the desire is to only capture the next event fired, using Once might be a better solution. task.spawn(function() local msg, num = signal:Wait() print(msg, num) --&gt; &quot;Hello&quot;, 32 end) signal:Fire(&quot;Hello&quot;, 32)   "},{"title":"Destroy​","type":1,"pageTitle":"Signal","url":"/SimplyReplicate/api/Signal#Destroy","content":"&lt;/&gt; Signal:Destroy() → () Cleans up the signal. Technically, this is only necessary if the signal is created usingSignal.Wrap. Connections should be properly GC'd once the signal is no longer referenced anywhere. However, it is still good practice to include ways to strictly clean up resources. Calling Destroy on a signal will also disconnect all connections immediately. signal:Destroy()   "},{"title":"ConnectOnce​","type":1,"pageTitle":"Signal","url":"/SimplyReplicate/api/Signal#ConnectOnce","content":"deprecated in v1.3.0 &lt;/&gt; This was deprecated in v1.3.0 Use `Signal:Once` instead. Signal:ConnectOnce(fn: ConnectionFn) → SignalConnection  "}]